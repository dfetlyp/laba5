# laba5

## Структура проекта

* **image.hpp** — заголовочный файл
* **main.cpp** — основной файл
* **CMakeLists.txt** — файл для сборки проекта

## Структура Color (Цвет одного пикселя)

Тип данных **Color** представляет собой структуру, которая хранит три цветовых канала: красный (r), зеленый (g) и синий (b). Каждый канал представлен типом **uint8\_t** (целое число от 0 до 255). В структуре предусмотрены два конструктора: один по умолчанию (черный цвет — 0, 0, 0), и второй — с параметрами, позволяющий задать значения для каждого из каналов.

## Тип Image

Изображение представляется как двумерный вектор, где внешний вектор соответствует строкам изображения, а внутренний — пикселям в строке.

## Генерация случайного изображения

Для генерации случайного изображения используется функция, которая создает изображение заданного размера. Она инициализирует каждый пиксель случайным цветом с помощью генератора псевдослучайных чисел, основанного на текущем времени.

## Размытие одного пикселя

Для размытия конкретного пикселя используется функция, которая вычисляет средний цвет в окрестности 3x3. Для каждого пикселя суммируются значения всех трех каналов (красный, зеленый, синий) соседних пикселей, после чего рассчитывается среднее значение для каждого канала. Это дает эффект размытия для одного пикселя.

## Последовательное размытие

Последовательное размытие заключается в том, чтобы пройти по каждому пикселю изображения и применить к нему функцию размытия. Для этого создается копия изображения, и для каждого пикселя вызывается функция размытия, после чего результат записывается в копию. Полученное изображение и будет результатом размытия.

## Параллельное размытие с использованием потоков

Параллельное размытие выполняется с использованием нескольких потоков. Изображение делится на полосы, и каждый поток обрабатывает свою часть. В результате получается размытое изображение, обработанное быстрее, чем при последовательном подходе. Для синхронизации потоков используется механизм ожидания завершения всех потоков с помощью метода **join()**.

## Измерение времени выполнения

Для замера времени выполнения используется шаблонная функция, которая принимает на вход имя задачи и саму функцию, которую нужно выполнить. Она измеряет время работы функции и выводит результат в миллисекундах.

## Пример с атомарными операциями

В примере с атомарными операциями демонстрируется сравнение двух вариантов увеличения счетчика с использованием **mutex** и **atomic**. В обоих случаях запускаются несколько потоков, каждый из которых увеличивает счетчик. В случае использования мьютекса для защиты данных, процесс становится медленнее из-за блокировки, а с использованием атомарных операций выполнение происходит быстрее, поскольку для простых операций не требуется блокировка.

## Ответы на вопросы

1. **Результаты сравнения производительности**:

   * Последовательное размытие занимает 317 мс.
   * Параллельное размытие с 4 потоками занимает 194 мс.
   * Пример с атомарными операциями: с мьютексом выполнение занимает 162 мс, с атомарными операциями — 67 мс.

   Многопоточность позволяет эффективно использовать ресурсы процессора, сокращая время выполнения за счет параллельной обработки данных.

2. **Проблемы синхронизации и их решения**:
   Основные проблемы включают:

   * Одновременный доступ нескольких потоков к общим данным.
   * Взаимоблокировки.
   * Проблемы с производительностью.

   Способы решения:

   * **Мьютексы** (std::mutex) — блокируют доступ к общим данным, обеспечивая синхронизацию.
   * **Атомарные операции** (std::atomic) — для простых операций, они быстрее, чем мьютексы.
   * **Разделение данных** — разбиение данных между потоками, чтобы каждый поток работал с отдельным участком памяти.
